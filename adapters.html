

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>adapters &mdash; Pika 0.9.5 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Pika 0.9.5 documentation" href="index.html" />
    <link rel="next" title="callback" href="callback.html" />
    <link rel="prev" title="Frequently Asked Questions" href="faq.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="callback.html" title="callback"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="faq.html" title="Frequently Asked Questions"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pika 0.9.5 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="adapters">
<h1>adapters<a class="headerlink" href="#adapters" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following class level documentation is not intended for use by those using Pika in their applications. This documentation is for those who are extending Pika or otherwise working on the driver itself. For an overview of how to use adapters, please reference the <a class="reference internal" href="connecting.html"><em>Connecting to RabbitMQ</em></a> documentation.</p>
</div>
<div class="section" id="module-adapters.base_connection">
<span id="base-connection"></span><h2>base_connection<a class="headerlink" href="#module-adapters.base_connection" title="Permalink to this headline">¶</a></h2>
<p>Pika provides multiple adapters to connect to RabbitMQ:</p>
<ul class="simple">
<li><a class="reference internal" href="connecting.html#adapters-select-connection-selectconnection"><em>SelectConnection</em></a>: A native event based connection
adapter that implements select, kqueue, poll and epoll.</li>
<li><a class="reference internal" href="connecting.html#adapters-asyncore-connection-asyncoreconnection"><em>AsyncoreConnection</em></a>: Legacy adapter kept for
convenience of previous Pika users. It is recommended to use the
SelectConnection instead of AsyncoreConnection.</li>
<li><a class="reference internal" href="connecting.html#adapters-tornado-connection-tornadoconnection"><em>TornadoConnection</em></a>: Connection adapter for use
with the Tornado web framework.</li>
<li><a class="reference internal" href="connecting.html#adapters-blocking-connection-blockingconnection"><em>BlockingConnection</em></a>: Enables blocking,
synchronous operation on top of library for simple uses. This is not
recommended and is included for legacy reasons only.</li>
</ul>
<div class="section" id="baseconnection">
<h3>BaseConnection<a class="headerlink" href="#baseconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.base_connection.</tt><tt class="descname">BaseConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Base connection function to be extended as needed</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">add_timeout</tt><big>(</big><em>delay_sec</em>, <em>callback</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_erase_credentials</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd><p>Call the state manager who will figure out that we need to write.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_adapter_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Called if we are forced to disconnect for some reason from Connection</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Called internally when we know our socket is disconnected already</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_error</tt><big>(</big><em>error</em><big>)</big></dt>
<dd><p>Internal error handling method. Here we expect a <tt class="xref py py-meth docutils literal"><span class="pre">error()</span></tt> coming in
and will handle different socket errors differently.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_events</tt><big>(</big><em>fd</em>, <em>events</em>, <em>error=None</em><big>)</big></dt>
<dd><p>Our IO/Event loop have called us with events, so process them</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_read</tt><big>(</big><big>)</big></dt>
<dd><p>Read from the socket and call our on_data_available with the data</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_write</tt><big>(</big><big>)</big></dt>
<dd><p>We only get here when we have data to write, so try and send
Pika&#8217;s suggested buffer size of data (be nice to Windows)</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_manage_event_state</tt><big>(</big><big>)</big></dt>
<dd><p>We use this to manage the bitmask for reading/writing/error which
we want to use to have our io/event handler tell us when we can
read/write, etc</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.select_connection">
<span id="select-connection"></span><h2>select_connection<a class="headerlink" href="#module-adapters.select_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="selectconnection">
<h3>SelectConnection<a class="headerlink" href="#selectconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">SelectConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">SelectConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Connect to the given host and port</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">SelectConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd><p>Call the state manager who will figure out that we need to write then
call the poller&#8217;s poll function to force it to process events.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ioloop">
<h3>IOLoop<a class="headerlink" href="#ioloop" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.IOLoop">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">IOLoop</tt><a class="headerlink" href="#adapters.select_connection.IOLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Singlton wrapper that decides which type of poller to use, creates an
instance of it in start_poller and keeps the invoking application in a
blocking state by calling the pollers start method. Poller should keep
looping until IOLoop.instance().stop() is called or there is a socket
error.</p>
<p>Also provides a convenient pass-through for add_timeout and set_events</p>
<dl class="method">
<dt id="adapters.select_connection.IOLoop.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass through a deadline and handler to the active poller</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout if it&#8217;s still in the timeout stack of our poller</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.select_connection.IOLoop.poller_type">
<tt class="descname">poller_type</tt><a class="headerlink" href="#adapters.select_connection.IOLoop.poller_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.start_poller">
<tt class="descname">start_poller</tt><big>(</big><em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.start_poller" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the Poller, once started will take over for IOLoop.start()</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.update_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass in the events we want to process</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until we have a poller</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the poller&#8217;s event loop</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="selectpoller">
<h3>SelectPoller<a class="headerlink" href="#selectpoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.SelectPoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">SelectPoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller" title="Permalink to this definition">¶</a></dt>
<dd><p>Default behavior is to use Select since it&#8217;s the widest supported and has
all of the methods we need for child classes as well. One should only need
to override the update_handler and start methods for additional types.</p>
<dl class="attribute">
<dt id="adapters.select_connection.SelectPoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 1</em><a class="headerlink" href="#adapters.select_connection.SelectPoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Set our events to our current events</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="kqueuepoller">
<h3>KQueuePoller<a class="headerlink" href="#kqueuepoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.KQueuePoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">KQueuePoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.select_connection.KQueuePoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="adapters.select_connection.KQueuePoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 1</em><a class="headerlink" href="#adapters.select_connection.KQueuePoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pollpoller">
<h3>PollPoller<a class="headerlink" href="#pollpoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.PollPoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">PollPoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.select_connection.PollPoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="adapters.select_connection.PollPoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 1</em><a class="headerlink" href="#adapters.select_connection.PollPoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="epollpoller">
<h3>EPollPoller<a class="headerlink" href="#epollpoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.EPollPoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">EPollPoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller" title="Permalink to this definition">¶</a></dt>
<dd><p>EPoll and Poll function signatures match.</p>
<dl class="method">
<dt id="adapters.select_connection.EPollPoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="adapters.select_connection.EPollPoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 1</em><a class="headerlink" href="#adapters.select_connection.EPollPoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.asyncore_connection">
<span id="asyncore-connection"></span><h2>asyncore_connection<a class="headerlink" href="#module-adapters.asyncore_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="asyncoreconnection">
<h3>AsyncoreConnection<a class="headerlink" href="#asyncoreconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.asyncore_connection.</tt><tt class="descname">AsyncoreConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">AsyncoreConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Connect to our RabbitMQ boker using AsyncoreDispatcher, then setting
Pika&#8217;s suggested buffer size for socket reading and writing. We pass
the handle to self so that the AsyncoreDispatcher object can call back
into our various state methods.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd><p>We really can&#8217;t flush the socket in asyncore, so instead just use this
to toggle a flag that lets it know we want to write to the socket.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="asyncoredispatcher">
<h3>AsyncoreDispatcher<a class="headerlink" href="#asyncoredispatcher" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.asyncore_connection.</tt><tt class="descname">AsyncoreDispatcher</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>We extend <tt class="xref py py-meth docutils literal"><span class="pre">dispatcher()</span></tt> here and throw in everything we need to
handle both asyncore&#8217;s needs and pika&#8217;s. In the async adapter structure
we expect a ioloop behavior which includes timeouts and a start and stop
function.</p>
<p>Initialize the dispatcher, socket and our defaults. We turn of nageling
in the socket to allow for faster throughput.</p>
<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_connect</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required method. Is called on connection.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_close</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required method. Is called on close.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_read</tt><big>(</big><big>)</big></dt>
<dd><p>Read from the socket and call our on_data_available with the data</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_write</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required function, is called when we can write to the socket</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">writable</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required function, used to toggle the write bit on the
select poller. For some reason, if we return false while connecting
asyncore hangs, so we check for that explicitly and tell it that
it can write while it&#8217;s connecting.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">_process_timeouts</tt><big>(</big><big>)</big></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">start</tt><big>(</big><big>)</big></dt>
<dd><p>Pika Adapter IOLoop start function. This blocks until we are no longer
connected.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">stop</tt><big>(</big><big>)</big></dt>
<dd><p>Pika Adapter IOLoop stop function. When called, it will close an open
connection, exiting us out of the IOLoop running in start.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.tornado_connection">
<span id="tornado-connection"></span><h2>tornado_connection<a class="headerlink" href="#module-adapters.tornado_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tornadoconnection">
<h3>TornadoConnection<a class="headerlink" href="#tornadoconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.tornado_connection.</tt><tt class="descname">TornadoConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">TornadoConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Connect to the given host and port</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">TornadoConnection.</tt><tt class="descname">_adapter_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Disconnect from the RabbitMQ Broker</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.blocking_connection">
<span id="blocking-connection"></span><h2>blocking_connection<a class="headerlink" href="#module-adapters.blocking_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="blockingconnection">
<h3>BlockingConnection<a class="headerlink" href="#blockingconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingConnection</tt><big>(</big><em>parameters=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><p>The BlockingConnection adapter is meant for simple implementations where
you want to have blocking behavior. The behavior layered on top of the
async library. Because of the nature of AMQP there are a few callbacks
one needs to do, even in a blocking implementation. These include receiving
messages from Basic.Deliver, Basic.GetOk, and Basic.Return.</p>
<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">disconnect</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">_adapter_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Called if we are forced to disconnect for some reason from Connection</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">_handle_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Called internally when we know our socket is disconnected already</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">process_data_events</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">channel</tt><big>(</big><em>channel_number=None</em><big>)</big></dt>
<dd><p>Create a new channel with the next available or specified channel #</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">add_timeout</tt><big>(</big><em>delay_sec</em>, <em>callback</em><big>)</big></dt>
<dd><p>Add a timeout calling callback to our stack that will execute
in delay_sec.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">process_timeouts</tt><big>(</big><big>)</big></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="blockingchannel">
<h3>BlockingChannel<a class="headerlink" href="#blockingchannel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingChannel</tt><big>(</big><em>connection</em>, <em>channel_number</em>, <em>transport=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_open</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_remote_close</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">basic_publish</tt><big>(</big><em>exchange</em>, <em>routing_key</em>, <em>body</em>, <em>properties=None</em>, <em>mandatory=False</em>, <em>immediate=False</em><big>)</big></dt>
<dd><p>Publish to the channel with the given exchange, routing key and body.</p>
<p>If flow control is enabled and you publish a message while another is
sending, a ContentTransmissionForbidden exception ill be generated</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">start_consuming</tt><big>(</big><big>)</big></dt>
<dd><p>Starts consuming from registered callbacks.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">stop_consuming</tt><big>(</big><em>consumer_tag=None</em><big>)</big></dt>
<dd><p>Sends off the Basic.Cancel to let RabbitMQ know to stop consuming and
sets our internal state to exit out of the basic_consume.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">basic_get</tt><big>(</big><em>ticket=0</em>, <em>queue=None</em>, <em>no_ack=False</em><big>)</big></dt>
<dd><p>Get a single message from the AMQP broker. The response will include
either a single method frame of Basic.GetEmpty or three frames:
the method frame (Basic.GetOk), header frame and
the body, like the reponse from Basic.Consume.  For more information
on basic_get and its parameters, see:</p>
<p><a class="reference external" href="http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.get">http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.get</a></p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_basic_get</tt><big>(</big><em>caller</em>, <em>method_frame</em>, <em>header_frame</em>, <em>body</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_basic_get_empty</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="blockingchanneltransport">
<h3>BlockingChannelTransport<a class="headerlink" href="#blockingchanneltransport" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingChannelTransport</tt><big>(</big><em>connection</em>, <em>channel_number</em><big>)</big></dt>
<dd><dl class="attribute">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">no_response_frame</tt><em class="property"> = ['Basic.Ack', 'Basic.Reject', 'Basic.RecoverAsync']</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">add_reply</tt><big>(</big><em>reply</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">remove_reply</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">rpc</tt><big>(</big><em>method</em>, <em>callback=None</em>, <em>acceptable_replies=None</em><big>)</big></dt>
<dd><p>Shortcut wrapper to the Connection&#8217;s rpc command using its callback
stack, passing in our channel number</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">_on_rpc_complete</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">send_method</tt><big>(</big><em>method</em>, <em>content=None</em>, <em>wait=True</em><big>)</big></dt>
<dd><p>Shortcut wrapper to send a method through our connection, passing in
our channel number</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">adapters</a><ul>
<li><a class="reference internal" href="#module-adapters.base_connection">base_connection</a><ul>
<li><a class="reference internal" href="#baseconnection">BaseConnection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.select_connection">select_connection</a><ul>
<li><a class="reference internal" href="#selectconnection">SelectConnection</a></li>
<li><a class="reference internal" href="#ioloop">IOLoop</a></li>
<li><a class="reference internal" href="#selectpoller">SelectPoller</a></li>
<li><a class="reference internal" href="#kqueuepoller">KQueuePoller</a></li>
<li><a class="reference internal" href="#pollpoller">PollPoller</a></li>
<li><a class="reference internal" href="#epollpoller">EPollPoller</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.asyncore_connection">asyncore_connection</a><ul>
<li><a class="reference internal" href="#asyncoreconnection">AsyncoreConnection</a></li>
<li><a class="reference internal" href="#asyncoredispatcher">AsyncoreDispatcher</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.tornado_connection">tornado_connection</a><ul>
<li><a class="reference internal" href="#tornadoconnection">TornadoConnection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.blocking_connection">blocking_connection</a><ul>
<li><a class="reference internal" href="#blockingconnection">BlockingConnection</a></li>
<li><a class="reference internal" href="#blockingchannel">BlockingChannel</a></li>
<li><a class="reference internal" href="#blockingchanneltransport">BlockingChannelTransport</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="faq.html"
                        title="previous chapter">Frequently Asked Questions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="callback.html"
                        title="next chapter">callback</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/adapters.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="callback.html" title="callback"
             >next</a> |</li>
        <li class="right" >
          <a href="faq.html" title="Frequently Asked Questions"
             >previous</a> |</li>
        <li><a href="index.html">Pika 0.9.5 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Tony Garnock-Jones, Gavin M. Roy and others.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1pre.
    </div>
  </body>
</html>